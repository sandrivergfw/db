/**
 * tdesign v0.24.9
 * (c) 2022 tdesign
 * @license MIT
 */

import _defineProperty from '@babel/runtime/helpers/defineProperty';
import log from '../log/log.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var SIZE_MAP = {
  B: 1,
  KB: 1024,
  MB: 1048576,
  GB: 1073741824
};
function returnFileSize(number) {
  if (number < SIZE_MAP.KB) {
    return "".concat(number, " Bytes");
  }
  if (number >= SIZE_MAP.KB && number < SIZE_MAP.MB) {
    return "".concat((number / SIZE_MAP.KB).toFixed(1), " KB");
  }
  if (number >= SIZE_MAP.MB && number < SIZE_MAP.GB) {
    return "".concat((number / SIZE_MAP.MB).toFixed(1), " MB");
  }
  if (number >= SIZE_MAP.GB) {
    return "".concat((number / SIZE_MAP.GB).toFixed(1), " GB");
  }
  return "";
}
function getCurrentDate() {
  var needTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var d = new Date();
  var month = d.getMonth() + 1;
  month = month < 10 ? "0".concat(month) : month;
  var date = "".concat(d.getFullYear(), "-").concat(month, "-").concat(d.getDate());
  var time = "".concat(d.getHours(), ":").concat(d.getMinutes(), ":").concat(d.getSeconds());
  if (needTime) return [date, time].join(" ");
  return date;
}
function abridgeName(inputName) {
  var leftCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
  var rightCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 7;
  var name = inputName;
  var leftLength = 0;
  var rightLength = 0;
  if (!name) return "";
  for (var i = 0; i < name.length; i++) {
    var w = name[i];
    var isCn = escape(w).indexOf("%u") === 0;
    if (i < leftCount * 2 && leftLength < leftCount) {
      isCn ? leftLength += 1 : leftLength += 2;
    } else if (i > i - rightCount && rightLength < rightCount) {
      isCn ? rightLength += 1 : rightLength += 2;
    }
  }
  return name.replace(new RegExp("^(.{".concat(leftLength, "})(.+)(.{").concat(rightLength, "})$")), "$1\u2026$3");
}
function getFileSizeText(number) {
  if (number < 1024) {
    return "".concat(number, " Bytes");
  }
  if (number >= 1024 && number < 1048576) {
    return "".concat((number / 1024).toFixed(1), " KB");
  }
  if (number >= 1048576) {
    return "".concat((number / 1048576).toFixed(1), " MB");
  }
  return "";
}
function isOverSizeLimit(fileSize, sizeLimit, unit) {
  var units = ["B", "KB", "MB", "GB"];
  var KBIndex = 1;
  var index = units.indexOf(unit);
  if (index === -1) {
    log.warn("Upload", "`sizeLimit.unit` can only be one of ".concat(units.join()));
    index = KBIndex;
  }
  var num = SIZE_MAP[unit];
  return fileSize > sizeLimit * num;
}
function isOverSizeLimit1(fileSize, sizeLimit, unit) {
  var units = ["B", "KB", "MB", "GB"];
  var KBIndex = 1;
  var index = units.indexOf(unit);
  if (index === -1) {
    console.warn("TDesign Upload Warn: `sizeLimit.unit` can only be one of ".concat(units.join()));
    index = KBIndex;
  }
  var num = SIZE_MAP[unit];
  var limit = index < KBIndex ? sizeLimit / num : sizeLimit * num;
  return fileSize <= limit;
}
var urlCreator = function urlCreator() {
  return window.webkitURL || window.URL;
};
function formatFiles() {
  var files = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var format = arguments.length > 1 ? arguments[1] : undefined;
  return files.map(function (fileRaw) {
    var _urlCreator;
    var file = typeof format === "function" ? format(fileRaw) : fileRaw;
    var uploadFile = _objectSpread({
      raw: fileRaw,
      lastModified: fileRaw.lastModified,
      name: fileRaw.name,
      size: fileRaw.size,
      type: fileRaw.type,
      percent: 0,
      status: "waiting"
    }, file);
    uploadFile.url = (_urlCreator = urlCreator()) === null || _urlCreator === void 0 ? void 0 : _urlCreator.createObjectURL(fileRaw);
    return uploadFile;
  });
}
function getFileUrlByFileRaw(fileRaw) {
  return new Promise(function (resolve) {
    if (!fileRaw) {
      resolve("");
      return;
    }
    var reader = new FileReader();
    reader.readAsDataURL(fileRaw);
    reader.onload = function (event) {
      var _event$target;
      resolve((_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
    };
  });
}

export { SIZE_MAP, abridgeName, formatFiles, getCurrentDate, getFileSizeText, getFileUrlByFileRaw, isOverSizeLimit, isOverSizeLimit1, returnFileSize, urlCreator };
//# sourceMappingURL=utils.js.map
