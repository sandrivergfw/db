/**
 * tdesign v0.24.9
 * (c) 2022 tdesign
 * @license MIT
 */

import { toRefs, inject, ref } from 'vue';
import throttle from 'lodash/throttle';
import { dragInjectKey } from '../constants.js';
import '../../hooks/useConfig.js';
import '../../config-provider/useConfig.js';
import '../../config-provider/context.js';
import 'lodash/mergeWith';
import 'lodash/merge';
import '../../_common/js/global-config/default-config.js';
import '../../_common/js/global-config/locale/zh_CN.js';
import '../../config-provider/type.js';

function useDraggable(props) {
  var _toRefs = toRefs(props),
    nodeRef = _toRefs.nodeRef,
    node = _toRefs.node;
  var onDrag = inject(dragInjectKey);
  var isDragOver = ref(false);
  var isDragging = ref(false);
  var dropPosition = ref(0);
  var updateDropPosition = throttle(function (e) {
    if (!nodeRef.value) return;
    var rect = nodeRef.value.getBoundingClientRect();
    var offsetY = window.pageYOffset + rect.top;
    var pageY = e.pageY;
    var gapHeight = rect.height / 4;
    var diff = pageY - offsetY;
    if (diff < gapHeight) {
      dropPosition.value = -1;
    } else if (diff < rect.height - gapHeight) {
      dropPosition.value = 0;
    } else {
      dropPosition.value = 1;
    }
  });
  var setDragStatus = function setDragStatus(status, e) {
    var _onDrag$onDragStart, _onDrag$onDragEnd, _onDrag$onDragOver, _onDrag$onDragLeave, _onDrag$onDrop;
    switch (status) {
      case "dragStart":
        isDragging.value = true;
        dropPosition.value = 0;
        (_onDrag$onDragStart = onDrag.onDragStart) === null || _onDrag$onDragStart === void 0 ? void 0 : _onDrag$onDragStart.call(onDrag, {
          node: node.value,
          e: e
        });
        break;
      case "dragEnd":
        isDragging.value = false;
        isDragOver.value = false;
        dropPosition.value = 0;
        updateDropPosition.cancel();
        (_onDrag$onDragEnd = onDrag.onDragEnd) === null || _onDrag$onDragEnd === void 0 ? void 0 : _onDrag$onDragEnd.call(onDrag, {
          node: node.value,
          e: e
        });
        break;
      case "dragOver":
        isDragOver.value = true;
        updateDropPosition(e);
        (_onDrag$onDragOver = onDrag.onDragOver) === null || _onDrag$onDragOver === void 0 ? void 0 : _onDrag$onDragOver.call(onDrag, {
          node: node.value,
          e: e
        });
        break;
      case "dragLeave":
        isDragOver.value = false;
        dropPosition.value = 0;
        updateDropPosition.cancel();
        (_onDrag$onDragLeave = onDrag.onDragLeave) === null || _onDrag$onDragLeave === void 0 ? void 0 : _onDrag$onDragLeave.call(onDrag, {
          node: node.value,
          e: e
        });
        break;
      case "drop":
        (_onDrag$onDrop = onDrag.onDrop) === null || _onDrag$onDrop === void 0 ? void 0 : _onDrag$onDrop.call(onDrag, {
          node: node.value,
          dropPosition: dropPosition.value,
          e: e
        });
        isDragOver.value = false;
        updateDropPosition.cancel();
        break;
      default:
        break;
    }
  };
  return {
    isDragOver: isDragOver,
    isDragging: isDragging,
    dropPosition: dropPosition,
    setDragStatus: setDragStatus
  };
}

export { useDraggable as default };
//# sourceMappingURL=useDraggable.js.map
