/**
 * tdesign v0.24.9
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../../_chunks/dep-a9a65d10.mjs';
import { _ as _defineProperty } from '../../_chunks/dep-b077039f.mjs';
import { toRefs, ref, reactive, computed, watch, onMounted, onBeforeUnmount } from 'vue';
import { g as get_1 } from '../../_chunks/dep-8513ec81.mjs';
import { d as debounce_1 } from '../../_chunks/dep-ec5c33ee.mjs';
import '../../_common/js/log/index.mjs';
import getScrollbarWidth from '../../_common/js/utils/getScrollbarWidth.mjs';
import { off, on } from '../../utils/dom.mjs';
import { getIEVersion } from '../../_common/js/utils/helper.mjs';
import log from '../../_common/js/log/log.mjs';
import '../../_chunks/dep-7fde6385.mjs';
import '../../_chunks/dep-bedb7d80.mjs';
import '../../_chunks/dep-e03d87af.mjs';
import '../../_chunks/dep-cacce51a.mjs';
import '../../_chunks/dep-178810f1.mjs';
import '../../_chunks/dep-1375bf98.mjs';
import '../../_chunks/dep-bfc93151.mjs';
import '../../_chunks/dep-74473837.mjs';
import '../../_chunks/dep-55f8205a.mjs';
import '../../_chunks/dep-4975791d.mjs';
import '../../_chunks/dep-ecf1f329.mjs';
import '../../_chunks/dep-7a4db73f.mjs';
import '../../_chunks/dep-da01978e.mjs';
import '../../_chunks/dep-e97b14c2.mjs';
import '../../_chunks/dep-61d894c9.mjs';
import '../../_chunks/dep-bc166b41.mjs';
import '../../_chunks/dep-a63b383f.mjs';
import '../../utils/easing.mjs';
import '../../_chunks/dep-4cfcf90d.mjs';
import '../../_chunks/dep-b9d3e48f.mjs';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function getColumnFixedStyles(col, index, rowAndColFixedPosition, tableColFixedClasses) {
  var _thClasses;
  var fixedPos = rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(col.colKey || index);
  if (!fixedPos) return {};
  var thClasses = (_thClasses = {}, _defineProperty(_thClasses, tableColFixedClasses.left, col.fixed === "left"), _defineProperty(_thClasses, tableColFixedClasses.right, col.fixed === "right"), _defineProperty(_thClasses, tableColFixedClasses.lastLeft, col.fixed === "left" && fixedPos.lastLeftFixedCol), _defineProperty(_thClasses, tableColFixedClasses.firstRight, col.fixed === "right" && fixedPos.firstRightFixedCol), _thClasses);
  var thStyles = {
    left: col.fixed === "left" ? "".concat(fixedPos.left, "px") : void 0,
    right: col.fixed === "right" ? "".concat(fixedPos.right, "px") : void 0
  };
  return {
    style: thStyles,
    classes: thClasses
  };
}
function getRowFixedStyles(rowId, rowIndex, rowLength, fixedRows, rowAndColFixedPosition, tableRowFixedClasses) {
  var _rowClasses;
  if (!fixedRows || !fixedRows.length) return {
    style: void 0,
    classes: void 0
  };
  var fixedTop = rowIndex < fixedRows[0];
  var fixedBottom = rowIndex > rowLength - 1 - fixedRows[1];
  var firstFixedBottomRow = rowLength - fixedRows[1];
  var fixedPos = (rowAndColFixedPosition === null || rowAndColFixedPosition === void 0 ? void 0 : rowAndColFixedPosition.get(rowId)) || {};
  var rowClasses = (_rowClasses = {}, _defineProperty(_rowClasses, tableRowFixedClasses.top, fixedTop), _defineProperty(_rowClasses, tableRowFixedClasses.bottom, fixedBottom), _defineProperty(_rowClasses, tableRowFixedClasses.firstBottom, rowIndex === firstFixedBottomRow), _defineProperty(_rowClasses, tableRowFixedClasses.withoutBorderBottom, rowIndex === firstFixedBottomRow - 1), _rowClasses);
  var rowStyles = {
    top: fixedTop ? "".concat(fixedPos.top, "px") : void 0,
    bottom: fixedBottom ? "".concat(fixedPos.bottom, "px") : void 0
  };
  return {
    style: rowStyles,
    classes: rowClasses
  };
}
function useFixed(props, context, finalColumns, affixRef) {
  var _toRefs = toRefs(props),
    columns = _toRefs.columns,
    tableLayout = _toRefs.tableLayout,
    tableContentWidth = _toRefs.tableContentWidth,
    fixedRows = _toRefs.fixedRows,
    firstFullRow = _toRefs.firstFullRow,
    lastFullRow = _toRefs.lastFullRow,
    maxHeight = _toRefs.maxHeight,
    headerAffixedTop = _toRefs.headerAffixedTop,
    footerAffixedBottom = _toRefs.footerAffixedBottom,
    bordered = _toRefs.bordered,
    resizable = _toRefs.resizable,
    allowResizeColumnWidth = _toRefs.allowResizeColumnWidth;
  var data = ref([]);
  var tableRef = ref();
  var tableContentRef = ref();
  var isFixedHeader = ref(false);
  var isWidthOverflow = ref(false);
  var tableElmRef = ref();
  var scrollbarWidth = ref(6);
  var rowAndColFixedPosition = ref( /* @__PURE__ */new Map());
  var showColumnShadow = reactive({
    left: false,
    right: false
  });
  var virtualScrollHeaderPos = ref({
    left: 0,
    top: 0
  });
  var tableWidth = ref(0);
  var tableElmWidth = ref(0);
  var thWidthList = ref({});
  var isFixedColumn = ref(false);
  var isFixedRightColumn = ref(false);
  var isFixedLeftColumn = ref(false);
  var columnResizable = computed(function () {
    return resizable.value || allowResizeColumnWidth.value || false;
  });
  var notNeedThWidthList = computed(function () {
    var _props$scroll;
    return !(props.headerAffixedTop || props.footerAffixedBottom || props.horizontalScrollAffixedBottom || ((_props$scroll = props.scroll) === null || _props$scroll === void 0 ? void 0 : _props$scroll.type) === "virtual");
  });
  var recalculateColWidth = ref(function () {});
  function setUseFixedTableElmRef(val) {
    tableElmRef.value = val;
  }
  function setRecalculateColWidthFuncRef(val) {
    recalculateColWidth.value = val;
  }
  function getColumnMap(columns2) {
    var map = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();
    var levelNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var parent = arguments.length > 4 ? arguments[4] : undefined;
    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children;
      var col = columns2[i];
      if (["left", "right"].includes(col.fixed)) {
        isFixedColumn.value = true;
      }
      if (col.fixed === "right") {
        isFixedRightColumn.value = true;
      }
      if (col.fixed === "left") {
        isFixedLeftColumn.value = true;
      }
      var key = col.colKey || i;
      var columnInfo = {
        col: col,
        parent: parent,
        index: i
      };
      map.set(key, columnInfo);
      if ((_col$children = col.children) !== null && _col$children !== void 0 && _col$children.length) {
        getColumnMap(col.children, map, levelNodes, level + 1, columnInfo);
      }
      if (levelNodes[level]) {
        levelNodes[level].push(columnInfo);
      } else {
        levelNodes[level] = [columnInfo];
      }
    }
    return {
      newColumnsMap: map,
      levelNodes: levelNodes
    };
  }
  var setFixedLeftPos = function setFixedLeftPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    for (var i = 0, len = columns2.length; i < len; i++) {
      var _col$children2;
      var col = columns2[i];
      if (col.fixed === "right") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i - 1;
      while (lastColIndex >= 0 && columns2[lastColIndex].fixed !== "left") {
        lastColIndex -= 1;
      }
      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === 0 ? (parent === null || parent === void 0 ? void 0 : parent.left) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i - 1);
      colInfo.left = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.left) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);
      if ((_col$children2 = col.children) !== null && _col$children2 !== void 0 && _col$children2.length) {
        setFixedLeftPos(col.children, initialColumnMap, colInfo);
      }
    }
  };
  var setFixedRightPos = function setFixedRightPos(columns2, initialColumnMap) {
    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    for (var i = columns2.length - 1; i >= 0; i--) {
      var _col$children3;
      var col = columns2[i];
      if (col.fixed === "left") return;
      var colInfo = initialColumnMap.get(col.colKey || i);
      var lastColIndex = i + 1;
      while (lastColIndex < columns2.length && columns2[lastColIndex].fixed !== "right") {
        lastColIndex += 1;
      }
      var lastCol = columns2[lastColIndex];
      var defaultWidth = i === columns2.length - 1 ? (parent === null || parent === void 0 ? void 0 : parent.right) || 0 : 0;
      var lastColInfo = initialColumnMap.get((lastCol === null || lastCol === void 0 ? void 0 : lastCol.colKey) || i + 1);
      colInfo.right = ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.right) || defaultWidth) + ((lastColInfo === null || lastColInfo === void 0 ? void 0 : lastColInfo.width) || 0);
      if ((_col$children3 = col.children) !== null && _col$children3 !== void 0 && _col$children3.length) {
        setFixedRightPos(col.children, initialColumnMap, colInfo);
      }
    }
  };
  var setFixedColPosition = function setFixedColPosition(trList, initialColumnMap) {
    if (!trList) return;
    for (var i = 0, len = trList.length; i < len; i++) {
      var thList = trList[i].children;
      for (var j = 0, thLen = thList.length; j < thLen; j++) {
        var _obj$col;
        var th = thList[j];
        var colKey = th.dataset.colkey;
        if (!colKey) {
          log.warn("TDesign Table", "".concat(th.innerText, " missing colKey. colKey is required for fixed column feature."));
        }
        var obj = initialColumnMap.get(colKey || j);
        if (obj !== null && obj !== void 0 && (_obj$col = obj.col) !== null && _obj$col !== void 0 && _obj$col.fixed) {
          initialColumnMap.set(colKey, _objectSpread(_objectSpread({}, obj), {}, {
            width: th.getBoundingClientRect().width
          }));
        }
      }
    }
    setFixedLeftPos(columns.value, initialColumnMap);
    setFixedRightPos(columns.value, initialColumnMap);
  };
  var setFixedRowPosition = function setFixedRowPosition(trList, initialColumnMap, thead, tfoot) {
    var _ref = fixedRows.value || [],
      _ref2 = _slicedToArray(_ref, 2),
      fixedTopRows = _ref2[0],
      fixedBottomRows = _ref2[1];
    var data2 = props.data,
      _props$rowKey = props.rowKey,
      rowKey = _props$rowKey === void 0 ? "id" : _props$rowKey;
    for (var i = 0; i < fixedTopRows; i++) {
      var tr = trList[i];
      var rowId = get_1(data2[i], rowKey);
      var thisRowInfo = initialColumnMap.get(rowId) || {};
      var lastRowId = get_1(data2[i - 1], rowKey);
      var lastRowInfo = initialColumnMap.get(lastRowId) || {};
      var defaultBottom = 0;
      if (i === 0) {
        defaultBottom = (thead === null || thead === void 0 ? void 0 : thead.getBoundingClientRect().height) || 0;
      }
      thisRowInfo.top = (lastRowInfo.top || defaultBottom) + (lastRowInfo.height || 0);
      initialColumnMap.set(rowId, _objectSpread(_objectSpread({}, thisRowInfo), {}, {
        height: tr.getBoundingClientRect().height
      }));
    }
    for (var _i = data2.length - 1; _i >= data2.length - fixedBottomRows; _i--) {
      var _tr = trList[_i];
      var _rowId = get_1(data2[_i], rowKey);
      var _thisRowInfo = initialColumnMap.get(_rowId) || {};
      var _lastRowId = get_1(data2[_i + 1], rowKey);
      var _lastRowInfo = initialColumnMap.get(_lastRowId) || {};
      var _defaultBottom = 0;
      if (_i === data2.length - 1) {
        _defaultBottom = (tfoot === null || tfoot === void 0 ? void 0 : tfoot.getBoundingClientRect().height) || 0;
      }
      _thisRowInfo.bottom = (_lastRowInfo.bottom || _defaultBottom) + (_lastRowInfo.height || 0);
      initialColumnMap.set(_rowId, _objectSpread(_objectSpread({}, _thisRowInfo), {}, {
        height: _tr.getBoundingClientRect().height
      }));
    }
  };
  var updateRowAndColFixedPosition = function updateRowAndColFixedPosition(tableContentElm, initialColumnMap) {
    rowAndColFixedPosition.value.clear();
    if (!tableContentElm) return;
    var thead = tableContentElm.querySelector("thead");
    thead && setFixedColPosition(thead.children, initialColumnMap);
    var tbody = tableContentElm.querySelector("tbody");
    var tfoot = tableContentElm.querySelector("tfoot");
    tbody && setFixedRowPosition(tbody.children, initialColumnMap, thead, tfoot);
    rowAndColFixedPosition.value = initialColumnMap;
  };
  var shadowLastScrollLeft;
  var updateColumnFixedShadow = function updateColumnFixedShadow(target, extra) {
    if (!isFixedColumn.value || !target) return;
    var scrollLeft = target.scrollLeft;
    if (shadowLastScrollLeft === scrollLeft && (!extra || !extra.skipScrollLimit)) return;
    shadowLastScrollLeft = scrollLeft;
    var isShowRight = target.clientWidth + scrollLeft < target.scrollWidth;
    showColumnShadow.left = scrollLeft > 0;
    showColumnShadow.right = isShowRight;
  };
  var setIsLastOrFirstFixedCol = function setIsLastOrFirstFixedCol(levelNodes) {
    for (var t = 0; t < levelNodes.length; t++) {
      var nodes = levelNodes[t];
      for (var i = 0, len = nodes.length; i < len; i++) {
        var _nextColMapInfo, _lastColMapInfo;
        var colMapInfo = nodes[i];
        var nextColMapInfo = nodes[i + 1];
        var parent = colMapInfo.parent;
        var isParentLastLeftFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.lastLeftFixedCol);
        if (isParentLastLeftFixedCol && colMapInfo.col.fixed === "left" && ((_nextColMapInfo = nextColMapInfo) === null || _nextColMapInfo === void 0 ? void 0 : _nextColMapInfo.col.fixed) !== "left") {
          colMapInfo.lastLeftFixedCol = true;
        }
        var lastColMapInfo = nodes[i - 1];
        var isParentFirstRightFixedCol = !parent || (parent === null || parent === void 0 ? void 0 : parent.firstRightFixedCol);
        if (isParentFirstRightFixedCol && colMapInfo.col.fixed === "right" && ((_lastColMapInfo = lastColMapInfo) === null || _lastColMapInfo === void 0 ? void 0 : _lastColMapInfo.col.fixed) !== "right") {
          colMapInfo.firstRightFixedCol = true;
        }
      }
    }
  };
  var updateFixedStatus = function updateFixedStatus() {
    var _getColumnMap = getColumnMap(columns.value),
      newColumnsMap = _getColumnMap.newColumnsMap,
      levelNodes = _getColumnMap.levelNodes;
    setIsLastOrFirstFixedCol(levelNodes);
    var timer = setTimeout(function () {
      var _fixedRows$value;
      if (isFixedColumn.value || (_fixedRows$value = fixedRows.value) !== null && _fixedRows$value !== void 0 && _fixedRows$value.length) {
        updateRowAndColFixedPosition(tableContentRef.value, newColumnsMap);
      }
      clearTimeout(timer);
    }, 0);
    return function () {
      clearTimeout(timer);
    };
  };
  var updateFixedHeader = function updateFixedHeader() {
    var timer = setTimeout(function () {
      if (!tableContentRef.value) return;
      isFixedHeader.value = tableContentRef.value.scrollHeight > tableContentRef.value.clientHeight;
      isWidthOverflow.value = tableContentRef.value.scrollWidth > tableContentRef.value.clientWidth;
      var pos = tableContentRef.value.getBoundingClientRect();
      virtualScrollHeaderPos.value = {
        top: pos.top,
        left: pos.left
      };
      clearTimeout(timer);
    }, 0);
  };
  var updateTableWidth = function updateTableWidth() {
    var _tableContentRef$valu, _tableElmRef$value;
    var rect = (_tableContentRef$valu = tableContentRef.value) === null || _tableContentRef$valu === void 0 ? void 0 : _tableContentRef$valu.getBoundingClientRect();
    if (!rect) return;
    var reduceWidth = isFixedHeader.value ? scrollbarWidth.value : 0;
    tableWidth.value = rect.width - reduceWidth - (props.bordered ? 1 : 0);
    var elmRect = tableElmRef === null || tableElmRef === void 0 ? void 0 : (_tableElmRef$value = tableElmRef.value) === null || _tableElmRef$value === void 0 ? void 0 : _tableElmRef$value.getBoundingClientRect();
    tableElmWidth.value = elmRect === null || elmRect === void 0 ? void 0 : elmRect.width;
  };
  var updateAffixPosition = function updateAffixPosition() {
    var _affixRef$paginationA, _affixRef$paginationA2, _affixRef$horizontalS, _affixRef$horizontalS2, _affixRef$headerTopAf, _affixRef$headerTopAf2, _affixRef$headerTopAf3;
    (_affixRef$paginationA = affixRef.paginationAffixRef.value) === null || _affixRef$paginationA === void 0 ? void 0 : (_affixRef$paginationA2 = _affixRef$paginationA.handleScroll) === null || _affixRef$paginationA2 === void 0 ? void 0 : _affixRef$paginationA2.call(_affixRef$paginationA);
    (_affixRef$horizontalS = affixRef.horizontalScrollAffixRef.value) === null || _affixRef$horizontalS === void 0 ? void 0 : (_affixRef$horizontalS2 = _affixRef$horizontalS.handleScroll) === null || _affixRef$horizontalS2 === void 0 ? void 0 : _affixRef$horizontalS2.call(_affixRef$horizontalS);
    (_affixRef$headerTopAf = affixRef.headerTopAffixRef) === null || _affixRef$headerTopAf === void 0 ? void 0 : (_affixRef$headerTopAf2 = _affixRef$headerTopAf.value) === null || _affixRef$headerTopAf2 === void 0 ? void 0 : (_affixRef$headerTopAf3 = _affixRef$headerTopAf2.handleScroll) === null || _affixRef$headerTopAf3 === void 0 ? void 0 : _affixRef$headerTopAf3.call(_affixRef$headerTopAf2);
  };
  var updateThWidthList = function updateThWidthList(trList) {
    if (trList instanceof HTMLCollection) {
      if (columnResizable.value) return;
      var widthMap = {};
      for (var i = 0, len = trList.length; i < len; i++) {
        var thList = trList[i].children;
        for (var j = 0, thLen = thList.length; j < thLen; j++) {
          var th = thList[j];
          var colKey = th.dataset.colkey;
          widthMap[colKey] = th.getBoundingClientRect().width;
        }
      }
      thWidthList.value = widthMap;
    } else {
      if (!thWidthList.value) {
        thWidthList.value = {};
      }
      Object.entries(trList).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          colKey = _ref4[0],
          width = _ref4[1];
        thWidthList.value[colKey] = width;
      });
    }
  };
  var updateThWidthListHandler = function updateThWidthListHandler() {
    if (columnResizable.value) {
      recalculateColWidth.value(finalColumns.value, thWidthList.value, tableLayout.value, tableElmWidth.value);
    }
    if (notNeedThWidthList.value) return;
    var timer = setTimeout(function () {
      var _tableContentRef$valu2;
      updateTableWidth();
      var thead = (_tableContentRef$valu2 = tableContentRef.value) === null || _tableContentRef$valu2 === void 0 ? void 0 : _tableContentRef$valu2.querySelector("thead");
      if (!thead) return;
      updateThWidthList(thead.children);
      clearTimeout(timer);
    }, 0);
  };
  var resetThWidthList = function resetThWidthList() {
    thWidthList.value = {};
  };
  var emitScrollEvent = function emitScrollEvent(e) {
    var _props$onScrollX, _props$onScrollY, _props$onScroll;
    (_props$onScrollX = props.onScrollX) === null || _props$onScrollX === void 0 ? void 0 : _props$onScrollX.call(props, {
      e: e
    });
    (_props$onScrollY = props.onScrollY) === null || _props$onScrollY === void 0 ? void 0 : _props$onScrollY.call(props, {
      e: e
    });
    (_props$onScroll = props.onScroll) === null || _props$onScroll === void 0 ? void 0 : _props$onScroll.call(props, {
      e: e
    });
  };
  var getThWidthList = function getThWidthList() {
    if (!thWidthList.value) {
      thWidthList.value = {};
    }
    return thWidthList.value;
  };
  watch([data, columns, bordered, tableLayout, tableContentWidth, isFixedHeader, isWidthOverflow, isFixedColumn, fixedRows, firstFullRow, lastFullRow], updateFixedStatus, {
    immediate: true
  });
  watch([isFixedColumn, columns], function () {
    var timer = setTimeout(function () {
      if (isFixedColumn.value) {
        updateColumnFixedShadow(tableContentRef.value);
      }
      clearTimeout(timer);
    }, 0);
  }, {
    immediate: true
  });
  watch([maxHeight, data, columns, bordered], updateFixedHeader, {
    immediate: true
  });
  watch(finalColumns, function () {
    resetThWidthList();
    if (columnResizable.value) {
      recalculateColWidth.value(finalColumns.value, thWidthList.value, tableLayout.value, tableElmWidth.value);
    }
  });
  watch([data, columns, bordered, tableLayout, fixedRows, isFixedHeader, headerAffixedTop, footerAffixedBottom, tableContentWidth], function () {
    updateThWidthListHandler();
    updateAffixPosition();
  }, {
    immediate: true
  });
  var refreshTable = debounce_1(function () {
    updateTableWidth();
    updateFixedHeader();
    updateThWidthListHandler();
    updateAffixPosition();
    if (isFixedColumn.value || isFixedHeader.value) {
      updateFixedStatus();
      updateColumnFixedShadow(tableContentRef.value, {
        skipScrollLimit: true
      });
    }
  }, 30);
  var onResize = refreshTable;
  var resizeObserver = null;
  function addTableResizeObserver(tableElement) {
    if (getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") return;
    off(window, "resize", onResize);
    resizeObserver = new window.ResizeObserver(function () {
      refreshTable();
    });
    resizeObserver.observe(tableElement);
    tableRef.value = tableElement;
  }
  onMounted(function () {
    var scrollWidth = getScrollbarWidth();
    scrollbarWidth.value = scrollWidth;
    var timer = setTimeout(function () {
      updateTableWidth();
      if (columnResizable.value) {
        recalculateColWidth.value(finalColumns.value, thWidthList.value, tableLayout.value, tableElmWidth.value);
      }
      clearTimeout(timer);
    });
    var isWatchResize = isFixedColumn.value || isFixedHeader.value || !notNeedThWidthList.value || !data.value.length;
    if (isWatchResize && getIEVersion() < 11 || typeof window.ResizeObserver === "undefined") {
      on(window, "resize", onResize);
    }
  });
  onBeforeUnmount(function () {
    var _resizeObserver, _resizeObserver2;
    off(window, "resize", onResize);
    (_resizeObserver = resizeObserver) === null || _resizeObserver === void 0 ? void 0 : _resizeObserver.unobserve(tableRef.value);
    (_resizeObserver2 = resizeObserver) === null || _resizeObserver2 === void 0 ? void 0 : _resizeObserver2.disconnect();
  });
  var setData = function setData(dataSource) {
    data.value = dataSource;
  };
  return {
    tableWidth: tableWidth,
    tableElmWidth: tableElmWidth,
    thWidthList: thWidthList,
    isFixedHeader: isFixedHeader,
    isWidthOverflow: isWidthOverflow,
    tableContentRef: tableContentRef,
    isFixedColumn: isFixedColumn,
    showColumnShadow: showColumnShadow,
    rowAndColFixedPosition: rowAndColFixedPosition,
    virtualScrollHeaderPos: virtualScrollHeaderPos,
    scrollbarWidth: scrollbarWidth,
    setData: setData,
    refreshTable: refreshTable,
    emitScrollEvent: emitScrollEvent,
    updateThWidthListHandler: updateThWidthListHandler,
    updateColumnFixedShadow: updateColumnFixedShadow,
    setUseFixedTableElmRef: setUseFixedTableElmRef,
    getThWidthList: getThWidthList,
    updateThWidthList: updateThWidthList,
    setRecalculateColWidthFuncRef: setRecalculateColWidthFuncRef,
    addTableResizeObserver: addTableResizeObserver
  };
}

export { useFixed as default, getColumnFixedStyles, getRowFixedStyles };
//# sourceMappingURL=useFixed.mjs.map
