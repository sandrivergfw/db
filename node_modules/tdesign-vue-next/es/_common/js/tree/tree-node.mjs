/**
 * tdesign v0.24.9
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _asyncToGenerator, r as regenerator } from '../../../_chunks/dep-9844db06.mjs';
import { _ as _toConsumableArray } from '../../../_chunks/dep-4cfcf90d.mjs';
import { _ as _classCallCheck, a as _createClass } from '../../../_chunks/dep-e677d52b.mjs';
import { _ as _defineProperty } from '../../../_chunks/dep-b077039f.mjs';
import '../../../_chunks/dep-bedb7d80.mjs';
import { t as toString_1 } from '../../../_chunks/dep-61d894c9.mjs';
import { i as isNil_1 } from '../../../_chunks/dep-e7aac5f1.mjs';
import { g as get_1 } from '../../../_chunks/dep-8513ec81.mjs';
import { createNodeModel, updateNodeModel } from './tree-node-model.mjs';
import '../../../_chunks/dep-178810f1.mjs';
import '../../../_chunks/dep-7fde6385.mjs';
import '../../../_chunks/dep-bfc93151.mjs';
import '../../../_chunks/dep-cacce51a.mjs';
import '../../../_chunks/dep-1375bf98.mjs';
import '../../../_chunks/dep-74473837.mjs';
import '../../../_chunks/dep-e03d87af.mjs';
import '../../../_chunks/dep-55f8205a.mjs';
import '../../../_chunks/dep-4975791d.mjs';
import '../../../_chunks/dep-ecf1f329.mjs';
import '../../../_chunks/dep-7a4db73f.mjs';
import '../../../_chunks/dep-da01978e.mjs';
import '../../../_chunks/dep-e97b14c2.mjs';
import '../../../_chunks/dep-cc833d5e.mjs';
import '../../../_chunks/dep-74d2e059.mjs';
import '../../../_chunks/dep-708d2dc7.mjs';
import '../../../_chunks/dep-df473a63.mjs';
import '../../../_chunks/dep-03d7fa8b.mjs';
import '../../../_chunks/dep-2aad0459.mjs';
import '../../../_chunks/dep-2539b27d.mjs';
import '../../../_chunks/dep-c62bd505.mjs';
import '../../../_chunks/dep-7934d0a9.mjs';
import '../../../_chunks/dep-180ba4d7.mjs';
import '../../../_chunks/dep-2a924a48.mjs';
import '../../../_chunks/dep-f7262050.mjs';
import '../../../_chunks/dep-dc72ac1e.mjs';
import '../../../_chunks/dep-df662d99.mjs';
import '../../../_chunks/dep-671fd175.mjs';
import '../../../_chunks/dep-ea278d31.mjs';
import '../../../_chunks/dep-cddb9124.mjs';
import '../../../_chunks/dep-7a8fb00c.mjs';
import '../../../_chunks/dep-0b20cec5.mjs';
import '../log/log.mjs';

var toString = toString_1;

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}
var uniqueId_1 = uniqueId;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var hasOwnProperty = Object.prototype.hasOwnProperty;
var defaultStatus = {
  expandMutex: false,
  activable: false,
  checkable: false,
  disabled: false,
  draggable: false,
  loading: false
};
var TreeNode = /*#__PURE__*/function () {
  function TreeNode(tree, data, parent) {
    _classCallCheck(this, TreeNode);
    _defineProperty(this, "tree", void 0);
    _defineProperty(this, "value", void 0);
    _defineProperty(this, "label", void 0);
    _defineProperty(this, "data", void 0);
    _defineProperty(this, "parent", void 0);
    _defineProperty(this, "children", void 0);
    _defineProperty(this, "model", void 0);
    _defineProperty(this, "vmIsLeaf", void 0);
    _defineProperty(this, "vmIsFirst", void 0);
    _defineProperty(this, "vmIsLast", void 0);
    _defineProperty(this, "vmIsRest", void 0);
    _defineProperty(this, "vmIsLocked", void 0);
    _defineProperty(this, "expanded", void 0);
    _defineProperty(this, "expandMutex", void 0);
    _defineProperty(this, "actived", void 0);
    _defineProperty(this, "activable", void 0);
    _defineProperty(this, "checkable", void 0);
    _defineProperty(this, "vmCheckable", void 0);
    _defineProperty(this, "checked", void 0);
    _defineProperty(this, "indeterminate", void 0);
    _defineProperty(this, "disabled", void 0);
    _defineProperty(this, "draggable", void 0);
    _defineProperty(this, "visible", void 0);
    _defineProperty(this, "level", void 0);
    _defineProperty(this, "loading", void 0);
    this.data = data;
    this.tree = tree;
    var config = tree.config || {};
    var prefix = config.prefix || "t";
    var keys = get_1(tree, "config.keys") || {};
    var propChildren = keys.children || "children";
    var propLabel = keys.label || "label";
    var propValue = keys.value || "value";
    this.model = null;
    this.children = null;
    this.vmCheckable = false;
    this.vmIsLeaf = false;
    this.vmIsFirst = false;
    this.vmIsLast = false;
    this.vmIsRest = true;
    this.vmIsLocked = false;
    var spec = _objectSpread(_objectSpread({}, defaultStatus), {}, {
      actived: false,
      expanded: false,
      checked: false
    }, data);
    var children = spec[propChildren];
    this.set(spec);
    this.label = spec[propLabel] || "";
    this.value = isNil_1(spec[propValue]) ? uniqueId_1(prefix) : spec[propValue];
    this.tree.nodeMap.set(this.value, this);
    if (parent && parent instanceof TreeNode) {
      this.parent = parent;
    } else {
      this.parent = null;
    }
    if (children === true) {
      this.children = children;
    }
    this.level = 0;
    this.visible = true;
    this.actived = spec.actived;
    this.initActived();
    this.expanded = spec.expanded;
    this.initExpanded();
    this.checked = spec.checked;
    this.initChecked();
    this.update();
    tree.reflow(this);
    if (Array.isArray(children)) {
      this.append(children);
    } else if (children === true && !config.lazy) {
      this.loadChildren();
    }
    this.checked = false;
    this.indeterminate = false;
    this.updateChecked();
  }
  _createClass(TreeNode, [{
    key: "initChecked",
    value: function initChecked() {
      var tree = this.tree,
        value = this.value,
        parent = this.parent;
      var checkStrictly = tree.config.checkStrictly;
      var checked = this.checked;
      checked = parent === null || parent === void 0 ? void 0 : parent.isChecked();
      if (checked && !checkStrictly) {
        tree.checkedMap.set(value, true);
      }
      this.checked = checked;
    }
  }, {
    key: "initExpanded",
    value: function initExpanded() {
      var tree = this.tree;
      var expanded = this.expanded;
      var config = tree.config;
      if (typeof config.expandLevel === "number" && this.getLevel() < config.expandLevel) {
        tree.expandedMap.set(this.value, true);
        expanded = true;
      }
      if (config.expandAll) {
        expanded = true;
      }
      if (this.children === true && config.lazy) {
        expanded = false;
      }
      if (expanded) {
        tree.expandedMap.set(this.value, true);
      } else {
        tree.expandedMap["delete"](this.value);
      }
      this.expanded = expanded;
    }
  }, {
    key: "initActived",
    value: function initActived() {
      var tree = this.tree,
        actived = this.actived;
      if (actived) {
        tree.activedMap.set(this.value, true);
      }
    }
  }, {
    key: "append",
    value: function append(data) {
      var _this = this;
      var list = [];
      if (!Array.isArray(data)) {
        list.push(data);
      } else {
        list.push.apply(list, _toConsumableArray(data));
      }
      if (list.length <= 0) {
        return;
      }
      if (!Array.isArray(this.children)) {
        this.children = [];
      }
      var children = this.children,
        tree = this.tree;
      list.forEach(function (item) {
        var node = null;
        if (item instanceof TreeNode) {
          node = item;
          node.appendTo(_this.tree, _this);
        } else {
          node = new TreeNode(_this.tree, item, _this);
          children.push(node);
        }
      });
      tree.reflow(this);
      this.updateRelated();
    }
  }, {
    key: "appendTo",
    value: function appendTo(tree, parent, index) {
      var _this2 = this;
      var parentNode = parent;
      var targetIndex = -1;
      if (typeof index === "number") {
        targetIndex = index;
      }
      var targetParents = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.getParents()) || [];
      var includeCurrent = targetParents.some(function (pnode) {
        return pnode === _this2;
      });
      if (includeCurrent) {
        throw new Error("\u65E0\u6CD5\u5C06\u7236\u8282\u70B9\u63D2\u5165\u5230\u5B50\u8282\u70B9");
      }
      if (Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {
        var targetPosNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.children[targetIndex];
        if (targetPosNode && targetPosNode === this) {
          return;
        }
      }
      var siblings = null;
      if (parentNode instanceof TreeNode) {
        if (!Array.isArray(parentNode === null || parentNode === void 0 ? void 0 : parentNode.children)) {
          parentNode.children = [];
        }
        siblings = parent.children;
      } else {
        siblings = tree.children;
      }
      if (!Array.isArray(siblings)) {
        throw new Error("\u65E0\u6CD5\u63D2\u5165\u5230\u76EE\u6807\u4F4D\u7F6E\uFF0C\u53EF\u63D2\u5165\u7684\u8282\u70B9\u5217\u8868\u4E0D\u5B58\u5728");
      }
      var prevLength = siblings.length;
      var prevIndex = this.getIndex();
      this.remove();
      if (typeof index === "number") {
        var targetIndex2 = index;
        if (parentNode === this.parent) {
          var curLength = siblings.length;
          if (curLength < prevLength && prevIndex <= targetIndex2) {
            targetIndex2 -= 1;
          }
        }
        siblings.splice(targetIndex2, 0, this);
      } else {
        siblings.push(this);
      }
      this.parent = parentNode;
      var nodes = this.walk();
      nodes.forEach(function (item) {
        var node = item;
        node.tree = tree;
        tree.nodeMap.set(node.value, node);
        if (node.expanded) {
          tree.expandedMap.set(node.value, true);
        }
      });
      var updateNodes = (parentNode === null || parentNode === void 0 ? void 0 : parentNode.walk()) || tree.children.map(function (item) {
        return item.walk();
      }).flat();
      updateNodes.forEach(function (node) {
        node.update();
        node.updateChecked();
      });
      tree.reflow();
    }
  }, {
    key: "insert",
    value: function insert(item, index) {
      var tree = this.tree,
        parent = this.parent;
      var siblings = this.getSiblings();
      var node = null;
      if (item instanceof TreeNode) {
        node = item;
        node.appendTo(tree, parent, index);
      } else if (item) {
        node = new TreeNode(tree, item, parent);
        if (typeof index === "number") {
          siblings.splice(index, 0, node);
        }
        siblings.forEach(function (sibling) {
          sibling.update();
        });
      }
      tree.reflow();
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(newData) {
      var index = this.getIndex();
      this.insert(newData, index);
    }
  }, {
    key: "insertAfter",
    value: function insertAfter(newData) {
      var index = this.getIndex();
      this.insert(newData, index + 1);
    }
  }, {
    key: "remove",
    value: function remove() {
      var tree = this.tree;
      var nodes = this.walk();
      var siblings = this.getSiblings();
      var index = this.getIndex();
      if (Array.isArray(siblings)) {
        siblings.splice(index, 1);
      }
      nodes.forEach(function (node) {
        node.clean();
      });
      siblings.forEach(function (node) {
        node.update();
      });
      this.updateParents();
      tree.reflow();
    }
  }, {
    key: "clean",
    value: function clean() {
      var tree = this.tree,
        value = this.value;
      tree.activedMap["delete"](value);
      tree.checkedMap["delete"](value);
      tree.expandedMap["delete"](value);
      tree.nodeMap["delete"](value);
    }
  }, {
    key: "loadChildren",
    value: function () {
      var _loadChildren = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var config, list;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                config = get_1(this, "tree.config") || {};
                if (!(this.children === true && !this.loading)) {
                  _context.next = 13;
                  break;
                }
                if (!(typeof config.load === "function")) {
                  _context.next = 13;
                  break;
                }
                this.loading = true;
                this.update();
                list = [];
                _context.next = 8;
                return config.load(this);
              case 8:
                list = _context.sent;
                this.tree.emit("load", {
                  node: this,
                  data: list
                });
                this.loading = false;
                if (Array.isArray(list) && list.length > 0) {
                  this.append(list);
                } else {
                  this.children = false;
                }
                this.update();
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
      function loadChildren() {
        return _loadChildren.apply(this, arguments);
      }
      return loadChildren;
    }()
  }, {
    key: "set",
    value: function set(item) {
      var _this3 = this;
      var tree = this.tree;
      var keys = Object.keys(item);
      keys.forEach(function (key) {
        if (hasOwnProperty.call(defaultStatus, key) || key === "label") {
          _this3[key] = item[key];
        }
      });
      tree.updated(this);
    }
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parent;
    }
  }, {
    key: "getParents",
    value: function getParents() {
      var parents = [];
      var node = this.parent;
      while (node) {
        parents.push(node);
        node = node.parent;
      }
      return parents;
    }
  }, {
    key: "getSiblings",
    value: function getSiblings() {
      var parent = this.parent,
        tree = this.tree;
      var list = [];
      if (parent) {
        if (Array.isArray(parent.children)) {
          list = parent.children;
        }
      } else if (tree) {
        list = tree.children;
      }
      return list;
    }
  }, {
    key: "getRoot",
    value: function getRoot() {
      var parents = this.getParents();
      return parents[parents.length - 1] || null;
    }
  }, {
    key: "getIndex",
    value: function getIndex() {
      var list = this.getSiblings();
      return list.indexOf(this);
    }
  }, {
    key: "getPath",
    value: function getPath() {
      var nodes = this.getParents();
      nodes.unshift(this);
      return nodes.reverse();
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      var parents = this.getParents();
      return parents.length;
    }
  }, {
    key: "isRest",
    value: function isRest() {
      var _this$tree = this.tree,
        config = _this$tree.config,
        filterMap = _this$tree.filterMap;
      var rest = true;
      if (typeof config.filter === "function") {
        var nodeModel = this.getModel();
        rest = config.filter(nodeModel);
      }
      if (rest) {
        filterMap.set(this.value, true);
      } else if (filterMap.get(this.value)) {
        filterMap["delete"](this.value);
      }
      return rest;
    }
  }, {
    key: "isVisible",
    value: function isVisible() {
      var nodeMap = this.tree.nodeMap;
      var visible = true;
      if (this.vmIsLocked) {
        return true;
      }
      if (nodeMap.get(this.value)) {
        var filterVisible = this.isRest();
        var expandVisible = true;
        var parents = this.getParents();
        if (parents.length > 0) {
          expandVisible = parents.every(function (node) {
            return node.isExpanded();
          });
        }
        visible = expandVisible && filterVisible;
      } else {
        visible = false;
      }
      return visible;
    }
  }, {
    key: "isDisabled",
    value: function isDisabled() {
      if (this.vmIsLocked) return true;
      var treeDisabled = get_1(this, "tree.config.disabled");
      return !!(treeDisabled || this.disabled);
    }
  }, {
    key: "isDraggable",
    value: function isDraggable() {
      return !!(get_1(this, "tree.config.draggable") || this.draggable);
    }
  }, {
    key: "isExpandMutex",
    value: function isExpandMutex() {
      return !!(get_1(this, "tree.config.expandMutex") || this.expandMutex);
    }
  }, {
    key: "isActivable",
    value: function isActivable() {
      return !!(get_1(this, "tree.config.activable") || this.activable);
    }
  }, {
    key: "isCheckable",
    value: function isCheckable() {
      return !!(get_1(this, "tree.config.checkable") || this.checkable);
    }
  }, {
    key: "isActived",
    value: function isActived(map) {
      var tree = this.tree,
        value = this.value;
      var activedMap = map || tree.activedMap;
      return !!(tree.nodeMap.get(value) && activedMap.get(value));
    }
  }, {
    key: "isExpanded",
    value: function isExpanded(map) {
      var tree = this.tree,
        value = this.value,
        vmIsLocked = this.vmIsLocked;
      if (vmIsLocked) return true;
      var expandedMap = map || tree.expandedMap;
      return !!(tree.nodeMap.get(value) && expandedMap.get(value));
    }
  }, {
    key: "isChecked",
    value: function isChecked(map) {
      var children = this.children,
        tree = this.tree;
      var checkStrictly = tree.config.checkStrictly;
      var checked = false;
      var checkedMap = map || tree.checkedMap;
      if (tree.nodeMap.get(this.value)) {
        if (checkedMap.get(this.value)) {
          checked = true;
        } else if (Array.isArray(children) && children.length > 0 && !checkStrictly) {
          checked = children.every(function (node) {
            var childIsChecked = node.isChecked(checkedMap);
            return childIsChecked;
          });
        } else if (!checkStrictly) {
          var parents = this.getParents();
          checked = parents.some(function (node) {
            return checkedMap.get(node.value);
          });
        }
      }
      return !!checked;
    }
  }, {
    key: "isIndeterminate",
    value: function isIndeterminate() {
      var children = this.children,
        tree = this.tree;
      var checkStrictly = tree.config.checkStrictly;
      if (checkStrictly) {
        return false;
      }
      var indeterminate = false;
      if (Array.isArray(children)) {
        var childChecked = null;
        indeterminate = children.some(function (node) {
          if (node.isIndeterminate()) {
            return true;
          }
          if (childChecked === null) {
            childChecked = node.isChecked();
          }
          if (childChecked !== node.isChecked()) {
            return true;
          }
          return false;
        });
      }
      return indeterminate;
    }
  }, {
    key: "isFirst",
    value: function isFirst() {
      var siblings = this.getSiblings();
      return siblings[0] === this;
    }
  }, {
    key: "isLast",
    value: function isLast() {
      var siblings = this.getSiblings();
      return siblings[siblings.length - 1] === this;
    }
  }, {
    key: "isLeaf",
    value: function isLeaf() {
      var isLeaf = false;
      if (Array.isArray(this.children)) {
        isLeaf = this.children.length <= 0;
      } else {
        isLeaf = !this.children;
      }
      return isLeaf;
    }
  }, {
    key: "lock",
    value: function lock(lockState) {
      this.vmIsLocked = lockState;
      this.expanded = this.isExpanded();
      this.visible = this.isVisible();
    }
  }, {
    key: "afterExpanded",
    value: function afterExpanded() {
      this.update();
      if (this.expanded && this.children === true) {
        this.loadChildren();
      }
    }
  }, {
    key: "toggleExpanded",
    value: function toggleExpanded() {
      return this.setExpanded(!this.isExpanded());
    }
  }, {
    key: "setExpanded",
    value: function setExpanded(expanded, opts) {
      var tree = this.tree;
      var options = _objectSpread({
        directly: false
      }, opts);
      var map = tree.expandedMap;
      if (!options.directly) {
        map = new Map(tree.expandedMap);
      }
      if (expanded) {
        var shouldExpandNodes = [];
        shouldExpandNodes.push(this);
        if (get_1(tree, "config.expandParent")) {
          this.getParents().forEach(function (node) {
            shouldExpandNodes.push(node);
          });
        }
        shouldExpandNodes.forEach(function (node) {
          var isExpandMutex = false;
          if (node.parent) {
            isExpandMutex = node.parent.isExpandMutex();
          } else {
            var _tree$config;
            isExpandMutex = tree === null || tree === void 0 ? void 0 : (_tree$config = tree.config) === null || _tree$config === void 0 ? void 0 : _tree$config.expandMutex;
          }
          if (isExpandMutex) {
            var siblings = node.getSiblings();
            siblings.forEach(function (snode) {
              map["delete"](snode.value);
            });
          }
          map.set(node.value, true);
        });
      } else {
        map["delete"](this.value);
      }
      if (options.directly) {
        this.afterExpanded();
        this.update();
        this.updateChildren();
      }
      return tree.getExpanded(map);
    }
  }, {
    key: "toggleActived",
    value: function toggleActived() {
      return this.setActived(!this.isActived());
    }
  }, {
    key: "setActived",
    value: function setActived(actived, opts) {
      var tree = this.tree;
      var options = _objectSpread({
        directly: false
      }, opts);
      var config = tree.config || {};
      var map = tree.activedMap;
      if (!options.directly) {
        map = new Map(tree.activedMap);
      }
      if (this.isActivable()) {
        if (actived) {
          if (!config.activeMultiple) {
            map.clear();
          }
          map.set(this.value, true);
        } else {
          map["delete"](this.value);
        }
      }
      if (options.directly) {
        this.update();
      }
      return tree.getActived(map);
    }
  }, {
    key: "toggleChecked",
    value: function toggleChecked() {
      return this.setChecked(!this.isChecked());
    }
  }, {
    key: "setChecked",
    value: function setChecked(checked, opts) {
      var tree = this.tree;
      var config = tree.config || {};
      var options = _objectSpread({
        directly: false
      }, opts);
      var map = tree.checkedMap;
      if (!options.directly) {
        map = new Map(tree.checkedMap);
      }
      if (this.isCheckable() && checked !== this.isChecked()) {
        if (config.checkStrictly) {
          if (checked) {
            map.set(this.value, true);
          } else {
            map["delete"](this.value);
          }
        } else {
          var children = this.walk();
          children.forEach(function (node) {
            if (checked) {
              map.set(node.value, true);
            } else {
              map["delete"](node.value);
            }
          });
          var parents = this.getParents();
          parents.forEach(function (node) {
            map["delete"](node.value);
          });
        }
      }
      if (options.directly) {
        if (config.checkStrictly) {
          this.updateChecked();
        } else {
          var relatedNodes = tree.getRelatedNodes([this.value]);
          relatedNodes.forEach(function (node) {
            node.updateChecked();
          });
        }
      }
      return tree.getChecked(map);
    }
  }, {
    key: "update",
    value: function update() {
      this.level = this.getLevel();
      this.actived = this.isActived();
      this.expanded = this.isExpanded();
      this.vmCheckable = this.isCheckable();
      this.visible = this.isVisible();
      this.vmIsRest = this.isRest();
      this.vmIsFirst = this.isFirst();
      this.vmIsLast = this.isLast();
      this.vmIsLeaf = this.isLeaf();
      this.tree.updated(this);
    }
  }, {
    key: "updateChecked",
    value: function updateChecked(isFromValueChange) {
      var tree = this.tree;
      this.vmCheckable = this.isCheckable();
      if (this.vmCheckable && (!this.disabled || isFromValueChange)) {
        this.checked = this.isChecked();
        if (this.checked) {
          tree.checkedMap.set(this.value, true);
        }
        this.indeterminate = this.isIndeterminate();
        tree.updated(this);
      }
    }
  }, {
    key: "updateChildren",
    value: function updateChildren() {
      var children = this.children;
      if (Array.isArray(children)) {
        children.forEach(function (node) {
          node.update();
          node.updateChecked();
          node.updateChildren();
        });
      }
    }
  }, {
    key: "updateParents",
    value: function updateParents() {
      var parent = this.parent;
      if (parent) {
        parent.update();
        parent.updateChecked();
        parent.updateParents();
      }
    }
  }, {
    key: "updateRelated",
    value: function updateRelated() {
      var tree = this.tree;
      var relatedNodes = tree.getRelatedNodes([this.value]);
      relatedNodes.forEach(function (node) {
        node.update();
        node.updateChecked();
      });
      tree.reflow();
    }
  }, {
    key: "walk",
    value: function walk() {
      var children = this.children;
      var list = [];
      list.push(this);
      if (Array.isArray(children) && children.length > 0) {
        children.forEach(function (node) {
          list = list.concat(node.walk());
        });
      }
      return list;
    }
  }, {
    key: "getModel",
    value: function getModel() {
      var model = this.model;
      if (!model) {
        model = createNodeModel(this);
        this.model = model;
      }
      updateNodeModel(model, this);
      return model;
    }
  }]);
  return TreeNode;
}();

export { TreeNode, TreeNode as default };
//# sourceMappingURL=tree-node.mjs.map
