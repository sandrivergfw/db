/**
 * tdesign v0.24.9
 * (c) 2022 tdesign
 * @license MIT
 */

import { _ as _slicedToArray } from '../../_chunks/dep-a9a65d10.mjs';
import { _ as _defineProperty } from '../../_chunks/dep-b077039f.mjs';
import { defineComponent, toRefs, ref, reactive, computed, watch, onMounted, nextTick, createVNode } from 'vue';
import { d as debounce_1 } from '../../_chunks/dep-ec5c33ee.mjs';
import '../../_chunks/dep-bedb7d80.mjs';
import { _ as _isIterateeCall } from '../../_chunks/dep-560cf0c7.mjs';
import { a as toFinite_1, t as toInteger_1, c as customParseFormat } from '../../_chunks/dep-cdc28404.mjs';
import { a as _baseToString, t as toString_1 } from '../../_chunks/dep-61d894c9.mjs';
import { _ as _hasUnicode, a as _castSlice, b as _stringToArray } from '../../_chunks/dep-5179d432.mjs';
import { d as dayjs } from '../../_chunks/dep-ba2c55ff.mjs';
import { panelColProps } from './props.mjs';
import { EPickerCols, TIME_FORMAT, TWELVE_HOUR_FORMAT, MERIDIEM_LIST, AM, PM } from '../../_common/js/time-picker/const.mjs';
import { closestLookup } from '../../_common/js/time-picker/utils.mjs';
import '../../hooks/useConfig.mjs';
import { useConfig } from '../../config-provider/useConfig.mjs';
import '../../_chunks/dep-7fde6385.mjs';
import '../../_chunks/dep-7a4db73f.mjs';
import '../../_chunks/dep-178810f1.mjs';
import '../../_chunks/dep-ecf1f329.mjs';
import '../../_chunks/dep-bfc93151.mjs';
import '../../_chunks/dep-bc166b41.mjs';
import '../../_chunks/dep-1375bf98.mjs';
import '../../_chunks/dep-74473837.mjs';
import '../../_chunks/dep-e97b14c2.mjs';
import '../../_chunks/dep-ea278d31.mjs';
import '../../_chunks/dep-da01978e.mjs';
import '../../_chunks/dep-2539b27d.mjs';
import '../../_chunks/dep-03d7fa8b.mjs';
import '../../_chunks/dep-cacce51a.mjs';
import '../../_chunks/dep-7a8fb00c.mjs';
import '../props.mjs';
import '../../_chunks/dep-10b9d296.mjs';
import '../../_chunks/dep-dc72ac1e.mjs';
import '../../_chunks/dep-55f8205a.mjs';
import '../../_chunks/dep-4975791d.mjs';
import '../../_chunks/dep-df662d99.mjs';
import '../../_chunks/dep-671fd175.mjs';
import '../../_chunks/dep-708d2dc7.mjs';
import '../../_chunks/dep-df473a63.mjs';
import '../../_chunks/dep-2aad0459.mjs';
import '../../_chunks/dep-3374d433.mjs';
import '../../_chunks/dep-180ba4d7.mjs';
import '../../_chunks/dep-0b20cec5.mjs';
import '../../_common/js/global-config/default-config.mjs';
import '../../_common/js/global-config/locale/zh_CN.mjs';
import '../../config-provider/type.mjs';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil$1 = Math.ceil,
  nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange$1(start, end, step, fromRight) {
  var index = -1,
    length = nativeMax(nativeCeil$1((end - start) / (step || 1)), 0),
    result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}
var _baseRange = baseRange$1;

var baseRange = _baseRange,
  isIterateeCall = _isIterateeCall,
  toFinite = toFinite_1;

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange$1(fromRight) {
  return function (start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}
var _createRange = createRange$1;

var createRange = _createRange;

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();
var range_1 = range;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat$1(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);
  return result;
}
var _baseRepeat = baseRepeat$1;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty$1(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}
var _baseProperty = baseProperty$1;

var baseProperty = _baseProperty;

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize$1 = baseProperty('length');
var _asciiSize = asciiSize$1;

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
  rsComboMarksRange = "\\u0300-\\u036f",
  reComboHalfMarksRange = "\\ufe20-\\ufe2f",
  rsComboSymbolsRange = "\\u20d0-\\u20ff",
  rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
  rsVarRange = "\\ufe0e\\ufe0f";

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
  rsCombo = '[' + rsComboRange + ']',
  rsFitz = "\\ud83c[\\udffb-\\udfff]",
  rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
  rsNonAstral = '[^' + rsAstralRange + ']',
  rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
  rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
  rsZWJ = "\\u200d";

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
  rsOptVar = '[' + rsVarRange + ']?',
  rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
  rsSeq = rsOptVar + reOptMod + rsOptJoin,
  rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize$1(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}
var _unicodeSize = unicodeSize$1;

var asciiSize = _asciiSize,
  hasUnicode$1 = _hasUnicode,
  unicodeSize = _unicodeSize;

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize$2(string) {
  return hasUnicode$1(string) ? unicodeSize(string) : asciiSize(string);
}
var _stringSize = stringSize$2;

var baseRepeat = _baseRepeat,
  baseToString = _baseToString,
  castSlice = _castSlice,
  hasUnicode = _hasUnicode,
  stringSize$1 = _stringSize,
  stringToArray = _stringToArray;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;

/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding$1(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);
  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil(length / stringSize$1(chars)));
  return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
}
var _createPadding = createPadding$1;

var createPadding = _createPadding,
  stringSize = _stringSize,
  toInteger = toInteger_1,
  toString = toString_1;

/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */
function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);
  var strLength = length ? stringSize(string) : 0;
  return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
}
var padStart_1 = padStart;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
dayjs.extend(customParseFormat);
var timeArr = [EPickerCols.hour, EPickerCols.minute, EPickerCols.second, EPickerCols.milliSecond];
var panelOffset = {
  top: 15,
  bottom: 21
};
var SinglePanel = defineComponent({
  name: "TTimePickerPanelCol",
  props: _objectSpread(_objectSpread({}, panelColProps()), {}, {
    position: String,
    triggerScroll: Boolean,
    onChange: Function,
    resetTriggerScroll: Function,
    isShowPanel: Boolean
  }),
  setup: function setup(props) {
    var _toRefs = toRefs(props),
      steps = _toRefs.steps,
      value = _toRefs.value,
      format = _toRefs.format,
      position = _toRefs.position,
      triggerScroll = _toRefs.triggerScroll;
    var _useConfig = useConfig("timePicker"),
      globalConfig = _useConfig.globalConfig;
    var _useConfig2 = useConfig(),
      classPrefix = _useConfig2.classPrefix;
    var cols = ref([]);
    var bodyRef = ref();
    var maskRef = ref(null);
    var colsRef = reactive({
      0: null,
      1: null,
      2: null,
      3: null,
      4: null,
      5: null
    });
    var dayjsValue = computed(function () {
      var isStepsSet = !!steps.value.filter(function (v) {
        return v > 1;
      }).length;
      if (value.value) return dayjs(value.value, format.value);
      if (isStepsSet) return dayjs().hour(0).minute(0).second(0);
      return dayjs();
    });
    var panelClassName = computed(function () {
      return "".concat(classPrefix.value, "-time-picker__panel");
    });
    watch(function () {
      return dayjsValue.value;
    }, function () {
      if (dayjsValue.value) updateTimeScrollPos(true);
    });
    watch(function () {
      return triggerScroll.value;
    }, function () {
      if (triggerScroll.value) {
        updateTimeScrollPos(true);
      }
    });
    onMounted(function () {
      var match = format.value.match(TIME_FORMAT);
      var _match = _slicedToArray(match, 7),
        startCol = _match[1],
        hourCol = _match[2],
        minuteCol = _match[3],
        secondCol = _match[4],
        milliSecondCol = _match[5],
        endCol = _match[6];
      var meridiem = EPickerCols.meridiem,
        hour = EPickerCols.hour,
        minute = EPickerCols.minute,
        second = EPickerCols.second,
        milliSecond = EPickerCols.milliSecond;
      var renderCol = [startCol && meridiem, hourCol && hour, minuteCol && minute, secondCol && second, milliSecondCol && milliSecond, endCol && meridiem].filter(function (v) {
        return !!v;
      });
      cols.value = renderCol;
    });
    var getItemHeight = function getItemHeight() {
      var _maskRef$value;
      var maskDom = (_maskRef$value = maskRef.value) === null || _maskRef$value === void 0 ? void 0 : _maskRef$value.querySelector("div");
      if (!maskDom) {
        return {
          offsetHeight: 0,
          margin: 0
        };
      }
      return {
        offsetHeight: maskDom.offsetHeight,
        margin: parseInt(getComputedStyle(maskDom).marginTop, 10)
      };
    };
    var timeItemCanUsed = function timeItemCanUsed(col, el) {
      var colIdx = timeArr.indexOf(col);
      if (colIdx !== -1) {
        var _props$disableTime, _props$disableTime$ca, _props$disableTime$ca2;
        var params = [dayjsValue.value.hour(), dayjsValue.value.minute(), dayjsValue.value.second()];
        params[colIdx] = Number(el);
        return !((_props$disableTime = props.disableTime) !== null && _props$disableTime !== void 0 && (_props$disableTime$ca = _props$disableTime.call.apply(_props$disableTime, [props].concat(params, [{
          partial: position.value || "start"
        }]))) !== null && _props$disableTime$ca !== void 0 && (_props$disableTime$ca2 = _props$disableTime$ca[col]) !== null && _props$disableTime$ca2 !== void 0 && _props$disableTime$ca2.includes(Number(el)));
      }
      return true;
    };
    var getColList = function getColList(col) {
      var count = 0;
      if (timeArr.includes(col)) {
        var colIdx = timeArr.indexOf(col);
        var colStep = steps.value[colIdx] || 1;
        if (col === EPickerCols.hour) count = TWELVE_HOUR_FORMAT.test(format.value) ? 11 : 23;else if (col === EPickerCols.milliSecond) count = 999;else count = 59;
        var colList = range_1(0, count + 1, Number(colStep)).map(function (v) {
          return padStart_1(String(v), 2, "0");
        }) || [];
        return props.hideDisabledTime && !!props.disableTime ? colList.filter(function (t) {
          var _props$disableTime2, _props$disableTime2$c, _props$disableTime2$c2;
          var params = [dayjsValue.value.hour(), dayjsValue.value.minute(), dayjsValue.value.second()];
          params[colIdx] = Number(t);
          return !((_props$disableTime2 = props.disableTime) !== null && _props$disableTime2 !== void 0 && (_props$disableTime2$c = _props$disableTime2.call.apply(_props$disableTime2, [props].concat(params, [{
            partial: position.value || "start"
          }]))) !== null && _props$disableTime2$c !== void 0 && (_props$disableTime2$c2 = _props$disableTime2$c[col]) !== null && _props$disableTime2$c2 !== void 0 && _props$disableTime2$c2.includes(Number(t)));
        }) : colList;
      }
      return MERIDIEM_LIST;
    };
    var getScrollDistance = function getScrollDistance(col, time) {
      if (col === EPickerCols.hour && /[h]{1}/.test(format.value)) time %= 12;
      var itemIdx = getColList(col).indexOf(padStart_1(String(time), 2, "0"));
      var _getItemHeight = getItemHeight(),
        offsetHeight = _getItemHeight.offsetHeight,
        margin = _getItemHeight.margin;
      var timeItemTotalHeight = offsetHeight + margin;
      var distance = Math.abs(Math.max(0, itemIdx) * timeItemTotalHeight);
      return distance;
    };
    var handleScroll = function handleScroll(col, idx) {
      var _colsRef$idx, _props$onChange;
      var val;
      var formattedVal;
      if (!props.isShowPanel) return;
      var scrollTop = (((_colsRef$idx = colsRef[idx]) === null || _colsRef$idx === void 0 ? void 0 : _colsRef$idx.scrollTop) || 0) + panelOffset.top;
      var _getItemHeight2 = getItemHeight(),
        offsetHeight = _getItemHeight2.offsetHeight,
        margin = _getItemHeight2.margin;
      var timeItemTotalHeight = offsetHeight + margin;
      var colStep = Math.abs(Math.round(scrollTop / timeItemTotalHeight + 0.5));
      var meridiem = MERIDIEM_LIST[Math.min(colStep - 1, 1)].toLowerCase();
      if (Number.isNaN(colStep)) colStep = 1;
      if (timeArr.includes(col)) {
        var max = 59;
        if (col === EPickerCols.hour) max = /[h]{1}/.test(format.value) ? 11 : 23;else if (col === EPickerCols.milliSecond) max = 999;
        var colIdx = timeArr.indexOf(col);
        var availableArr = range_1(0, max + 1, Number(steps.value[colIdx]) || 1);
        val = closestLookup(availableArr, Number(getColList(col)[Math.min(colStep - 1, max + 1, availableArr.length - 1)]), Number(steps.value[colIdx]) || 1);
        if (Number.isNaN(val)) val = availableArr[availableArr.length - 1];
        if (col === EPickerCols.hour && cols.value.includes(EPickerCols.meridiem) && dayjsValue.value.hour() >= 12) {
          val = Number(val) + 12;
        }
      } else val = meridiem;
      var distance = getScrollDistance(col, val);
      if (!dayjs(dayjsValue.value).isValid() || value.value && !dayjs(value.value, format.value, true).isValid()) return;
      if (timeArr.includes(col)) {
        var _dayjsValue$value$col, _dayjsValue$value;
        if (timeItemCanUsed(col, val)) formattedVal = (_dayjsValue$value$col = (_dayjsValue$value = dayjsValue.value)[col]) === null || _dayjsValue$value$col === void 0 ? void 0 : _dayjsValue$value$col.call(_dayjsValue$value, val).format(format.value);
      } else {
        var currentHour = dayjsValue.value.hour();
        if (meridiem === AM && currentHour >= 12) {
          formattedVal = dayjsValue.value.hour(currentHour - 12).format(format.value);
        } else if (meridiem === PM && currentHour < 12) {
          formattedVal = dayjsValue.value.hour(currentHour + 12).format(format.value);
        } else {
          formattedVal = dayjsValue.value.format(format.value);
        }
      }
      if (formattedVal !== value.value) (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, formattedVal);
      if (distance !== scrollTop) {
        var _scrollCtrl$scrollTo;
        var scrollCtrl = colsRef[cols.value.indexOf(col)];
        if (!scrollCtrl || scrollCtrl.scrollTop === distance) return;
        (_scrollCtrl$scrollTo = scrollCtrl.scrollTo) === null || _scrollCtrl$scrollTo === void 0 ? void 0 : _scrollCtrl$scrollTo.call(scrollCtrl, {
          top: distance,
          behavior: "smooth"
        });
      }
    };
    var scrollToTime = function scrollToTime(col, time, idx) {
      var _scrollCtrl$scrollTo2;
      var behavior = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "auto";
      var distance = getScrollDistance(col, time);
      var scrollCtrl = colsRef[idx];
      if (!scrollCtrl || scrollCtrl.scrollTop === distance || !timeItemCanUsed(col, time)) return;
      (_scrollCtrl$scrollTo2 = scrollCtrl.scrollTo) === null || _scrollCtrl$scrollTo2 === void 0 ? void 0 : _scrollCtrl$scrollTo2.call(scrollCtrl, {
        top: distance,
        behavior: behavior
      });
    };
    var handleTimeItemClick = function handleTimeItemClick(col, el, idx) {
      if (!timeItemCanUsed(col, el)) return;
      if (timeArr.includes(col)) {
        if (col === EPickerCols.hour && dayjsValue.value.format("a") === PM && cols.value.includes(EPickerCols.meridiem)) {
          el = Number(el) + 12;
        }
        scrollToTime(col, el, idx, "smooth");
      } else {
        var currentHour = dayjsValue.value.hour();
        if (el === AM && currentHour >= 12) {
          props.onChange(dayjsValue.value.hour(currentHour - 12).format(format.value));
        } else if (el === PM && currentHour < 12) {
          props.onChange(dayjsValue.value.hour(currentHour + 12).format(format.value));
        }
      }
    };
    var updateTimeScrollPos = function updateTimeScrollPos() {
      var isAutoScroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var behavior = value.value && !isAutoScroll ? "smooth" : "auto";
      var isStepsSet = !!steps.value.filter(function (v) {
        return v > 1;
      }).length;
      nextTick(function () {
        cols.value.forEach(function (col, idx) {
          if (!isStepsSet || isStepsSet && value.value) {
            var _dayjsValue$value$col2, _dayjsValue$value2;
            scrollToTime(col, timeArr.includes(col) ? (_dayjsValue$value$col2 = (_dayjsValue$value2 = dayjsValue.value)[col]) === null || _dayjsValue$value$col2 === void 0 ? void 0 : _dayjsValue$value$col2.call(_dayjsValue$value2) : dayjsValue.value.format("a"), idx, behavior);
          } else {
            var _getColList;
            scrollToTime(col, (_getColList = getColList(col)) === null || _getColList === void 0 ? void 0 : _getColList[0], idx, behavior);
          }
        });
      });
      props.resetTriggerScroll();
    };
    var isCurrent = function isCurrent(col, colItem) {
      var _dayjsValue$value$col3, _dayjsValue$value3;
      var colVal;
      if (col === EPickerCols.meridiem) {
        var currentMeridiem = dayjsValue.value.format("a");
        return currentMeridiem === colItem;
      }
      colVal = (_dayjsValue$value$col3 = (_dayjsValue$value3 = dayjsValue.value)[col]) === null || _dayjsValue$value$col3 === void 0 ? void 0 : _dayjsValue$value$col3.call(_dayjsValue$value3);
      if (col === EPickerCols.hour && /[h]{1}/.test(format.value)) {
        colVal %= 12;
      }
      return colVal === Number(colItem);
    };
    return function () {
      var _cols$value$map, _cols$value, _cols$value$map2, _cols$value2;
      return createVNode("div", {
        "class": "".concat(panelClassName.value, "-body"),
        "ref": bodyRef
      }, [createVNode("div", {
        "class": "".concat(panelClassName.value, "-body-active-mask"),
        "ref": maskRef
      }, [(_cols$value$map = (_cols$value = cols.value).map) === null || _cols$value$map === void 0 ? void 0 : _cols$value$map.call(_cols$value, function (col, idx) {
        return createVNode("div", {
          "key": "".concat(col, "_").concat(idx)
        }, null);
      })]), (_cols$value$map2 = (_cols$value2 = cols.value).map) === null || _cols$value$map2 === void 0 ? void 0 : _cols$value$map2.call(_cols$value2, function (col, idx) {
        return createVNode("ul", {
          "key": "".concat(col, "_").concat(idx),
          "ref": function ref(el) {
            return colsRef[idx] = el;
          },
          "class": "".concat(panelClassName.value, "-body-scroll"),
          "onScroll": debounce_1(function () {
            return handleScroll(col, idx);
          }, 50)
        }, [getColList(col).map(function (el) {
          var _ref;
          return createVNode("li", {
            "key": el,
            "class": ["".concat(panelClassName.value, "-body-scroll-item"), (_ref = {}, _defineProperty(_ref, "".concat(classPrefix.value, "-is-disabled"), !timeItemCanUsed(col, el)), _defineProperty(_ref, "".concat(classPrefix.value, "-is-current"), isCurrent(col, el)), _ref)],
            "onClick": function onClick() {
              return handleTimeItemClick(col, el, idx);
            }
          }, [timeArr.includes(col) ? TWELVE_HOUR_FORMAT.test(format.value) && col === EPickerCols.hour && el === "00" ? "12" : el : globalConfig.value[el === AM ? "anteMeridiem" : "postMeridiem"]]);
        })]);
      })]);
    };
  }
});

export { SinglePanel as default };
//# sourceMappingURL=single-panel.mjs.map
